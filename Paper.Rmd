---
title: "Automated Quantification Pipeline"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source('src/functions.R')
```




```{r, echo = FALSE, message = FALSE, warning = FALSE}
detect_membranes_demo <-function(img, channels, factor, chan, cutoff, cnum)
{

  steps <- list()
 # chan <- normalize(chan)
  g <- gblur(chan*factor, sigma = 2)
  

  
  ct = thresh(g)
  cm = bwlabel(ct)
  fm <- computeFeatures.shape(cm)
  noise <- which(fm[,"s.area"]< cutoff) # noise removal
  
  keep_noise <- which(fm[,"s.area"] >= cutoff )
  cm_copy <- cm
  
  steps$g <- g
  steps$ct <- ct
  steps$noise <- rmObjects(cm_copy, keep_noise)
  
  
  
  membranes <- rmObjects(cm, noise)
  res <- remove_edge_membranes(membranes, img, channels, cnum)
  
  list(removed = res$removed, membranes = res$membranes, FM = res$FM, steps = steps)
}
```


```{r, echo = FALSE, message = FALSE, warning = FALSE}
exclude_and_bind_demo <- function(mems, vacs, cutoff)
{

  df <- data.frame(matrix(NA, nrow = length(table(mems$membranes)), ncol = 9))
  names(df) <- c('CellID', 'vacuoles', 'cell_area', 'vac_area', 'PM_vac_ratio', 'cell_mpi', 'vac_mpi', 'pm_center_x', 'pm_center_y')
  
  
  l = length(table(mems$membranes))-1
  empty_cells <- vector("list", l) # cells containing no detected vacuoles
  fragments <- vector("list", l) # PMs that not fully formed
  intra_cell <- vector('list', l)
  
  # Loop through list of PMs
  for(i in seq(1:l))
  {
    pm_seg = mems$membranes == i  # isolate PM
    filled_seg = fillHull(pm_seg) # flood fill
    comp <- pm_seg == filled_seg
    
  
    if(any(pm_seg*vacs$vacuoles) == 1)  # excludes accidentally intra cell fluorescence
    {
      fragments[i] = i   
      intra_cell[i] = i
    }
    # If # of pixels in PM is greater than intersection complement, add to 
    # fragment list.  This technique allows whole PMS with some 
    # minor gaps in fluorescence to make the cut. 
   
    else if(length(comp == FALSE) < 10)  # 10 pixel grace zone
      fragments[i] = i
    else  
    {
      # If not a fragment, search detected vacuoles within the cell. 
      v_seg <-vacs$vacuoles*(filled_seg-pm_seg)
      vcount <- table(v_seg)
      vcount <- vcount[-1] 
      # If no vacuoles detected, discard
      if( length(vcount) == 0 )
        empty_cells[i] = i
      else
      {
        c_area <-  mems$FM[i, 'membrane.0.s.area']
        v_area <- calc_vac_areas(as.numeric(names(vcount)), vacs$FV)
      
        if(v_area < (cutoff/10))
        {
          empty_cells[i] = i
        }
        else  # populate dataframe
        {
          cmpi <- mems$FM[i, 'membrane.a.b.mean']
          vmpi <- calc_vac_mpi(as.numeric(names(vcount)), vacs$FV)
          df[i,] <- list(CellID = i,
                         vacuoles = toString(names(vcount)),
                         cell_area =  c_area,
                         vac_area = v_area,
                         PM_vac_ratio = cmpi/vmpi,
                         cell_mpi = cmpi,
                         vac_mpi = vmpi,
                         pm_center_x = mems$FM[i,'membrane.0.m.cx'],
                         pm_center_y = mems$FM[i,'membrane.0.m.cy'])
        }
        
      }
    }
  }
  
  message(paste0(length(unlist(empty_cells))), " empty cells discarded.")
  message(paste0(length(unlist(fragments))), " membrane fragments discarded.")
  
  list(df=df, fragments = unlist(fragments), empty_cells = unlist(empty_cells), intra = unlist(intra_cell))
}
```



```{r, echo = FALSE, message = FALSE, warning = FALSE}
cnum = list(
  cmac_channel = 1,
  gfp_channel = 2,
  dic_channel = 3)
chan <- cnum$gfp_channel
cutoff <- "100"
fact <- 16
```


```{r, echo = FALSE, message = FALSE, warning = FALSE}
datasetpath <- "Datasets/Sample Dataset"
imageset <- read_in_imageset_files(datasetpath)
channels <- read_in_channels(imageset[1,], datasetpath, cnum)
img_gray <- convert_to_grayscale(channels)
membranes <- detect_membranes_demo(img_gray, channels, fact, img_gray[,,chan], as.numeric(cutoff), cnum)
vacuoles <- find_vacuoles(membranes, img_gray, channels, cnum)
res <- exclude_and_bind_demo(membranes, vacuoles, as.numeric(cutoff))
final<-tidy_up(membranes,vacuoles,res)

```



```{r, echo = FALSE, message = FALSE, warning = FALSE}

schann <- abind(channel(normalize(channels$cmac), 'asblue'), 
               channel(normalize(channels$gfp), 'asgreen'), 
               channel(channels$dic, 'rgb'), along = 1)
sig <- abind(channel(img_gray[,,cnum$cmac_channel], 'rgb'), 
             channel(img_gray[,,cnum$gfp_channel], 'rgb'), 
             channel(img_gray[,,cnum$dic_channel], 'rgb'), along= 1)
step1 <- abind(schann, sig, along = 2)
```


```{r, echo = FALSE, message = FALSE, warning = FALSE}
mpm <- membranes$membranes == 170
mint <- membranes$membranes == 175
mpm_filled <- fillHull(mpm)
mvacs <- vacuoles$vacuoles*mpm_filled

intraex <- paintObjects(mvacs, channel(mpm, 'rgb'), col = c('blue','blue'))

intraex <- paintObjects(mint, intraex, col = c('red','red'), opac = c(.5,.5))
intraex <- intraex[525:650,1075:1210,]
```


```{r, echo = FALSE, message = FALSE, warning = FALSE}
mfrag <- membranes$membranes == 22  #[175:250,100:175]
mem <- membranes$membranes == 39
p <- paintObjects(vacuoles$vacuoles, tgt = channel(mem, 'rgb'), col = c('blue','blue'))
mk <- paintObjects(mfrag, tgt = channel(channels$gfp, 'asgreen'), col = c('white','white'), opac = c(.5,.5))
mk <- mk[175:250,100:175,]
me <- paintObjects(mem, tgt = channel(channels$gfp, 'asgreen'), col = c('white','white'))
me <- me[1640:1700, 225:300,]
```




```{r, echo = FALSE, message = FALSE, warning = FALSE}
msteps <- membranes$steps

sct <- channel(msteps$ct, 'rgb')
snoise <- paintObjects(msteps$noise, tgt = sct, col = c('red','red'))
sedge <- paintObjects(membranes$removed, tgt=snoise, col = c('blue','blue'))

smems <- abind(sct, sedge, channel(membranes$membranes, 'rgb'), along = 1)
```



```{r, echo = FALSE, message = FALSE, warning = FALSE}
mems <- membranes$membranes
notfrags <- rmObjects(mems, res$fragments, reenumerate = FALSE)
frags <- rmObjects(mems, notfrags)

notintra <- rmObjects(mems, res$intra, reenumerate = FALSE)
intra <- rmObjects(mems, notintra)

notempty<- rmObjects(mems, res$empty_cells, reenumerate = FALSE)
empty <- rmObjects(mems, notempty)
```



```{r, echo = FALSE, message = FALSE, warning = FALSE}
#svac <- paintObjects(vacuoles$vacuoles, channel(channels$cmac, 'rgb'), col = c('blue','blue'))

sintra <- paintObjects(intra, tgt = channel(membranes$membranes, 'rgb'), col = c('red','red'))
sempty <- paintObjects(empty, tgt = sintra, col = c('red','red'))

sfinal <- paintObjects(final$vacuoles, tgt = channel(final$membranes, 'rgb'), col = c('blue','blue'))
```


```{r, echo = FALSE, message = FALSE, warning = FALSE}
sres <- abind(channel(vacuoles$vacuoles, 'asblue'), sempty, channel(final$membranes, 'rgb'), sfinal, along = 1)
```

# Overview 

The Automated Quantification Pipeline presented below is written in R version 3.6.3 with the following package dependencies:  

```
Bioconductor::EBImage
stringr
shiny
shinyFiles
shinyjs
shinythemes
tidyr
```

The user supplies the following criteria: 

* Channel order
* CellSize cutoff
* Brightness factor
* Membrane detection channel

# Pipeline

### Format conversion

If necessary, files can be converted from .nd2 to .tif files using FIJI's built in "Batch Convert" macro.  

### I/O

Tif files are read in and stored in an N x 2 matrix of the form 

$$
\left[
\begin{matrix}
\text{Image 1 Filename} & \text{Image 1 Filepath} \\
\vdots & \vdots \\
\text{Image N Filename} & \text{Image N Filepath}
\end{matrix}
\right]
$$

where N = number of files.  The rows (images) are processed in sequential order.

### Image Preprocessing

A local channel object stores information about the channels of the image using the user-supplied channel ordering. For each channel, two image matrices are stored:  

* Matrix of original pixel intensities of the channel, used for quantification

* Matrix of normalized pixel intensities of the channel, used for image manipulation and rendering

All normalized channels are then converted to grayscale.  


```{r, echo = FALSE, fig.cap= "Top Row: Image channels (normalized). Bottom Row: Channels converted to grayscale.", fig.align='center'}
display(step1,method="browser")
```

### Membrane Detection

First pass membrane detection is then initiated on the user-supplied channel.  This can be either the GFP channel (ideal for cells with sufficient fluorescence at the cell membrane) or the DIC channel (necessary when intracellular fluroescence is high with low localization at the cell membrane).  The detection channel is brightened by a user-supplied factor and the brightened image is passed through a low-pass Gaussian filter. A simple threshold is performed and noise is removed using the user-supplied cell size cutoff.  Any remaining membrane object that intersects with the boundaries of the image is then removed.  The remaining membrane objects constitute the set of first pass plasma membrane objects, which will be passed to the next stage of the pipeline.  A number of features are computed on this set using the reference of the detection channel image, including mean pixel intensity, minimum cell radius, xy coordinates, and area.


```{r, echo = FALSE, fig.cap= "Left: All membrane objects detected on the first pass.  Middle: Noise (red) and edge membranes (blue).   Right: Remaining membrane objects after removal.", fig.align='center'}
display(smems,method="browser")
```

### Vacuoles

Vacuoles are detected using adaptive thresholding on the CMAC channel. The adaptive window has a length and width equal to the largest minimum radius of any membrane object in the first-pass set.  The mean pixel intensity, xy coordinates, and area are computed on each detected vacuole object using the reference CMAC channel.

```{r, echo = FALSE, fig.align='center', fig.cap= "Left: Grayscale CMAC channel with adaptive window.  Right: First-pass vacuole objects."}
b <- max(membranes$FM[,"membrane.0.s.radius.min"]) 

par(mfrow=c(1,2))
plot(normalize(channels$cmac))
rect(10,10,10+b,10+b, border = "red")
plot(channel(vacuoles$vacuoles, 'asblue'))
```


### Filtering

The first-pass sets of the membrane and vacuole objects are then sent to a filtering method, where they are used in combination to exclude the cases outlined below. Each membrane object from the first-pass set is processed individually.


## Fragments  

A floodFill operation is performed on the PM object and the result is temporarily stored.  If only a portion of the membrane is present, the floodFilled object will be identical to the original object.  This comparison serves as the exclusionary criteria for fragmented objects.  There is a 10 pixel margin to allow for membrane objects that are fully formed but have very minor gaps in fluorescence.

```{r, echo = FALSE, fig.align='center', fig.cap="Example of a fragmented membrane object."}
display(mk,method="browser")
```



## Intracellular Fluorescence

The floodFilled object is again used, this time as a mask applied to the set of first-pass vacuole objects.  The result of this operation is a set of all vacuoles contained within the cell. The majority of intracellular fluorescence erroneously detected as a membrane object will intersect with the set of contained vacuoled and be marked for exclusion.  Additionally, this method will exclude any detected vacuole object that intersects with the cell membrane. 

```{r, echo = FALSE, fig.align = 'center', fig.cap="Example of intracellcular fluorescence (red) intersecting with contained vacuoles (blue)."}
display(intraex,method="browser")
```


## Empty cells

The method above may miss intracellular fluorescence that does not intersect with any contained vacuole. Those cases will be handled here, where any cell with a vacuole list of length 0 is excluded.  This not only covers the case above but also  cells that do not contain vacuoles at all.


```{r, echo = FALSE,fig.align = 'center', fig.cap="Example of an empty cell."}
display(me,method="browser")
```

```{r, echo = FALSE, fig.align = 'center', fig.cap="From left to right:  First-pass vacuole detection, Objects flagged by the filtering method, Removal of flagged objects, Remaining set of membranes and vacuoles."}
display(sres,method="browser")
```



# Output

The final membrane and vacuole objects are re-enumerated and stored in a dataframe, with each row containing a cell ID, vacuole ID, area of the cell membrane, combined area of the vacuole objects, the mean PM fluorescence, the mean vacuole fluorescence, and the PM/vac fluorescence ratio.  The dataframe is saved as a .csv file and an image is generated with the final membrane and vacuole objects painted on the GFP channel along with their CellID numbers. 

```{r, echo = FALSE}
final$df
```


